# -*- coding: utf-8 -*-
"""submission_pipeline_v0515_1600.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V8CHxvTZDpYBAmgX1PiA3HeKXYPU5Wab
"""

!pip install -q pysndfx SoundFile audiomentations pretrainedmodels efficientnet_pytorch timm
# !pip install -q resnest

# Commented out IPython magic to ensure Python compatibility.
# %%time 
# 
# import os
# import sys
# 
# if "google.colab" in sys.modules:
#     from google.colab import drive
#     drive.mount('/content/drive')
#     %cd /content/drive/MyDrive/kaggle/kaggle-birdclef-2021/notebook/
#     if not os.path.exists("/content/birdclef-2021"):
#         !unzip ../download/birdclef-2021.zip -d /content/birdclef-2021/
#         # !unzip ../download/kkiller-birdclef-2021.zip -d /content/kkiller-birdclef-2021/
#         !unzip ../download/effic-brid.zip -d /content/effic-brid/
#     
# !pip install -q "../input/resnest50-fast-package/resnest-0.0.6b20200701/resnest"
# 
# from resnest.torch import resnest50
# import numpy as np
# import librosa as lb
# import soundfile as sf
# import pandas as pd
# import cv2
# from pathlib import Path
# import re
# import timm
# import torch
# from torch import nn
# from  torch.utils.data import Dataset, DataLoader
# from efficientnet_pytorch import EfficientNet
# 
# from tqdm.notebook import tqdm
# import time

import sys
sys.path.append("../lib/")
import birdclef

class Config:
    def __init__(self, debug:bool):
        self.debug = debug
        self.model_names = [
            "resnest50",
            "resnext101_32x8d_wsl",
            "efficientnet-b3",
        ]

config = Config(debug=False)

NUM_CLASSES = 397
SR = 32_000 # サンプリリングレート
DURATION = 5
THRESH = 0.15

DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("DEVICE:", DEVICE)

TEST_AUDIO_ROOT = Path("/content/birdclef-2021/test_soundscapes")
SAMPLE_SUB_PATH = "/content/birdclef-2021/sample_submission.csv"
TARGET_PATH = None
    
if not len(list(TEST_AUDIO_ROOT.glob("*.ogg"))):
    TEST_AUDIO_ROOT = Path("/content/birdclef-2021/train_soundscapes")
    SAMPLE_SUB_PATH = None
    # SAMPLE_SUB_PATH = "../input/birdclef-2021/sample_submission.csv"
    TARGET_PATH = Path("/content/birdclef-2021/train_soundscape_labels.csv")

data = pd.DataFrame(
     [(path.stem, *path.stem.split("_"), path) for path in Path(TEST_AUDIO_ROOT).glob("*.ogg")],
    columns = ["filename", "id", "site", "date", "filepath"]
)
print(data.shape)
data.head()

df_train = pd.read_csv("/content/birdclef-2021/train_metadata.csv")

LABEL_IDS = {label: label_id for label_id,label in enumerate(sorted(df_train["primary_label"].unique()))}
INV_LABEL_IDS = {val: key for key,val in LABEL_IDS.items()}

test_data = birdclef.datasets.BirdCLEFDataset(data=data)
len(test_data), test_data[0].shape

print(config.model_names)
nets = []
if "resnest50" in config.model_names:
    entry = birdclef.registry.get_entry_by_id("resnest50")
    nets.append(
        birdclef.models.load_resnest50(
            checkpoint_path = entry.filepath
        )
    )

if "efficientnet-b3" in config.model_names:
    entry = birdclef.registry.get_entry_by_id("efficientnet-b3")
    nets.append(
        birdclef.models.load_effnetb3(
            checkpoint_path = entry.filepath
        )
    )

if "resnext101_32x8d_wsl" in config.model_names:
    entry = birdclef.registry.get_entry_by_id("resnext101_32x8d_wsl")
    nets.append(
        birdclef.models.load_wsl(
            name            = entry.id,
            checkpoint_path = entry.filepath
        )
    )

@torch.no_grad()
def get_thresh_preds(out, thresh=None):
    thresh = thresh or THRESH
    o = (-out).argsort(1)
    npreds = (out > thresh).sum(1)
    preds = []
    for oo, npred in zip(o, npreds):
        preds.append(oo[:npred].cpu().numpy().tolist())
    return preds

def get_bird_names(preds):
    bird_names = []
    for pred in preds:
        if not pred:
            bird_names.append("nocall")
        else:
            bird_names.append(" ".join([INV_LABEL_IDS[bird_id] for bird_id in pred]))
    return bird_names

def predict(nets, test_data, names=True):
    preds = []
    with torch.no_grad():
        for idx in  tqdm(list(range(len(test_data)))):
            xb = torch.from_numpy(test_data[idx]).to(DEVICE)
            pred = 0.
            for net in nets:
                o = net(xb)
                o = torch.sigmoid(o)

                pred += o

            pred /= len(nets)
            
            if names:
                pred = get_bird_names(get_thresh_preds(pred))

            preds.append(pred)
    return preds

pred_probas = predict(nets, test_data, names=False)
print(len(pred_probas))

preds = [get_bird_names(get_thresh_preds(pred, thresh=THRESH)) for pred in pred_probas]

def preds_as_df(data, preds):
    sub = {
        "row_id": [],
        "birds": [],
    }
    
    for row, pred in zip(data.itertuples(False), preds):
        row_id = [f"{row.id}_{row.site}_{5*i}" for i in range(1, len(pred)+1)]
        sub["birds"] += pred
        sub["row_id"] += row_id
        
    sub = pd.DataFrame(sub)
    
    if SAMPLE_SUB_PATH:
        sample_sub = pd.read_csv(SAMPLE_SUB_PATH, usecols=["row_id"])
        sub = sample_sub.merge(sub, on="row_id", how="left")
        sub["birds"] = sub["birds"].fillna("nocall")
    return sub

sub = preds_as_df(data, preds)
print(sub.shape)
sub

sub.to_csv("submission.csv", index=False)

if TARGET_PATH:
    sub_target = pd.read_csv(TARGET_PATH)
    sub_target = sub_target.merge(sub, how="left", on="row_id")
    
    print(sub_target["birds_x"].notnull().sum(), sub_target["birds_x"].notnull().sum())
    assert sub_target["birds_x"].notnull().all()
    assert sub_target["birds_y"].notnull().all()
    
    df_metrics = pd.DataFrame([
        birdclef.metrics.get_metrics(s_true, s_pred) for s_true, s_pred in zip(sub_target.birds_x, sub_target.birds_y)
    ])
    
    print(df_metrics.mean())

sub_target[sub_target.birds_y != "nocall"]

sub_target[sub_target.birds_x != "nocall"]

